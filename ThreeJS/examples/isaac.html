<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - particles - floor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			a {
				color:#0078ff;
			}
		</style>
	</head>
	<body>

		<script src="../build/three.min.js"></script>

		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>

		<script src="js/libs/stats.min.js"></script>
		<script src="particles.js"></script>
		<script type="text/javascript" src="js/controls/FirstPersonControls.js"></script>

		<script>
			var YawAngle = 0;
			var PitchAngle = 0;
			var ground;

			var space = false;
			var moveForward = false;
			var moveBackwards = false;
			var moveLeft = false;
			var moveRight = false;

			var SEPARATION = 100;
			var AMOUNTX = 50;
			var AMOUNTY = 50;


			var container, stats;
			var camera, scene, renderer, particle;
			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var clock;

			var light;
 
			var particleSystem;
			var particles;

			var velocities = [];

			var redParticleSystem;
			var redParticles;
			var redvelocities = []; 

			init();


			function init() {
				  var audio = document.createElement('audio');
				  var source = document.createElement('source');
				  source.src = '/sounds/donk.mp3';
				  audio.appendChild(source);
				  audio.play();

				clock = new THREE.Clock();

				container = document.createElement('div');
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.y = 120;
				camera.position.x = SEPARATION * AMOUNTX / 2
				camera.position.z = SEPARATION * AMOUNTY / 2
				

				scene = new THREE.Scene(); 

				// create the renderer
				renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0xffffee, .97 );

				// setup fog
				scene.fog = new THREE.FogExp2( 0xeeffff, 0.0010 );

				var spotLight = new THREE.SpotLight( 0xffffff );
				spotLight.position.set( SEPARATION * AMOUNTX, 200, SEPARATION * AMOUNTY);
				spotLight.castShadow = true;
				spotLight.intensity = 5;
				spotLight.shadowMapWidth = 1024;
				spotLight.shadowMapHeight = 1024;

				spotLight.shadowCameraNear = 500;
				spotLight.shadowCameraFar = 4000;
				spotLight.shadowCameraFov = 30;
				scene.add( spotLight );


				// var ambientlight = new THREE.AmbientLight( 0x404040 ); // soft white light
				// scene.add( ambientlight );

				// create the particle variables
				var pMaterial = new THREE.ParticleBasicMaterial({
					size: 20,
					map: THREE.ImageUtils.loadTexture(
					"textures/particle3.png"
					),
					transparent: true
				});

				var redPMaterial = new THREE.ParticleBasicMaterial({
					size: 5,
					map: THREE.ImageUtils.loadTexture(
					"textures/particle2.png"
					),
					transparent: true
				});

				particles = new THREE.Geometry();

				    
				// now create the individual particles
				for (var p = 0; p < 2000; p++) {

				  // create a particle with random
				  // position values, -250 -> 250
				  var pX = Math.random() * SEPARATION * AMOUNTX,
				      pY = Math.random() * 2000,
				      pZ = Math.random() * SEPARATION * AMOUNTY,
				      particle = new THREE.Vector3(pX, pY, pZ);

			        velocities.push([0, -Math.random() - 4, 0]);	

				  // add it to the geometry
				  particles.vertices.push(particle);
				}

				redParticles = new THREE.Geometry();

				for (var p = 0; p < 5000; p++) {

				  // create a particle with random
				  // position values, -250 -> 250
				  var pX = Math.random() * SEPARATION * AMOUNTX,
				      pY = Math.random() * 2000,
				      pZ = Math.random() * SEPARATION * AMOUNTY,
				      particle = new THREE.Vector3(pX, pY, pZ);

			        redvelocities.push([0, -Math.random() - 4, 0]);	

				  // add it to the geometry
				  redParticles.vertices.push(particle);
				}

				// create the particle system
				particleSystem = new THREE.ParticleSystem(
				    particles,
				    pMaterial);

				redParticleSystem = new THREE.ParticleSystem(
					    redParticles,
					    redPMaterial);

				redParticleSystem.sortParticles = true;
				particleSystem.sortParticles = true;

				// add it to the scene
				scene.add(particleSystem);
				scene.add(redParticleSystem);


				// declare geometry
				var geometry = new THREE.Geometry(); 
				geometry.verticesNeedUpdate = true;
				
				// add all of the vertices
				for ( var ix = 0; ix < AMOUNTX; ix++ ) 
				{
					for ( var iy = 0; iy < AMOUNTY; iy++ ) {
						geometry.vertices.push(new THREE.Vector3(ix * SEPARATION, 0, iy * SEPARATION));
					}
				}

				// create faces from the vertices
				for (var x = 0; x < AMOUNTX - 1; x++)
				{
					for (var y = 0; y < AMOUNTY - 1; y++)
					{
						var baseindex = x * AMOUNTX + y;

						geometry.faces.push(new THREE.Face3(baseindex, baseindex + 1, baseindex + AMOUNTX));
						geometry.faces.push(new THREE.Face3(baseindex + AMOUNTX, baseindex + 1, baseindex + AMOUNTX + 1));
					}
				}

				// compute the normals
				geometry.computeFaceNormals();

				// add the objects {overdraw: false }
				var material = new THREE.MeshPhongMaterial();
				material.fog = true;
				material.wireframe = false;
				material.color = new THREE.Color(.5, .5, .5);

				ground = new THREE.Mesh( geometry, material);
				scene.add(ground);
				
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				window.addEventListener( 'resize', onWindowResize, false );

				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );
			}


			function onDocumentKeyDown( event ) {
				console.log(event.keyCode);

				switch ( event.keyCode ) {
					case 32: space = true; break;
					case 87: moveForward = true; break; // up
					case 83: moveBackwards = true; break; // down
					case 65: moveLeft = true; break; // left
					case 68: moveRight = true; break; // right

				}

			}

			function onDocumentKeyUp( event ) {

				switch ( event.keyCode ) {
					case 32: space = false; break;
					case 87: moveForward = false; break; // up
					case 83: moveBackwards = false; break; // down
					case 65: moveLeft = false; break; // left
					case 68: moveRight = false; break; // right

				}

			}

			function onWindowResize() 
			{
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = -event.clientY + windowHalfY;
			}

			function animate() 
			{
				requestAnimationFrame( animate );

				render();
			}

			function render() {
				//console.log(velocities);

				FrameTime = clock.getDelta()

				for (var i = 0; i < particles.vertices.length; i++)
				{
					// check if we need to reset
					if (particles.vertices[i].y < -100) 
					{
						particles.vertices[i].y = 1000;
						velocities[i] = [0, -Math.random() - 4, 0];
					}

					// update the velocity with
					// a splat of randomniz
					velocities[i][0] += Math.random() - .5;
					velocities[i][2] += Math.random() - .5;
					//velocities[i][1] -= Math.random() / 8;

					// and the position
					particles.vertices[i].set(particles.vertices[i].x + velocities[i][0], particles.vertices[i].y + velocities[i][1], particles.vertices[i].z + velocities[i][2]);

					particleSystem.geometry.verticesNeedUpdate = true;
				}

				for (var i = 0; i < redParticles.vertices.length; i++)
				{
					// check if we need to reset
					if (redParticles.vertices[i].y < -100) 
					{
						redParticles.vertices[i].y = 1000;
						redvelocities[i] = [0, -Math.random() - 4, 0];
					}

					// update the velocity with
					// a splat of randomniz
					redvelocities[i][0] += (Math.random() - .5) / 4;
					redvelocities[i][2] += (Math.random() - .5) / 4;
					//velocities[i][1] -= Math.random() / 8;

					// and the position
					redParticles.vertices[i].set(redParticles.vertices[i].x + redvelocities[i][0], redParticles.vertices[i].y + redvelocities[i][1], redParticles.vertices[i].z + redvelocities[i][2]);

					redParticleSystem.geometry.verticesNeedUpdate = true;
				}

				



				if (Math.abs(mouseX) > 100)
				{
					YawAngle += mouseX / 10000.0;
				}

				var cameratarget = new THREE.Vector3( Math.cos(YawAngle), 0, Math.sin(YawAngle) );
				cameratarget.add(camera.position);
				camera.lookAt(cameratarget);


				var motiontarget = new THREE.Vector3(Math.cos(YawAngle), 0, Math.sin(YawAngle));
				
				var horizontalmotiontarget = motiontarget.clone();
				var axis = new THREE.Vector3( 0, 1, 0 );
				var angle = Math.PI / 2;
				horizontalmotiontarget.applyAxisAngle(axis, angle);

				if (moveForward == true)
				{
					camera.position.x += FrameTime * 100 * motiontarget.x;
					camera.position.z += FrameTime * 100 * motiontarget.z;
				}
				if (moveBackwards == true)
				{
					camera.position.z -= FrameTime * 100 * motiontarget.z;
					camera.position.x -= FrameTime * 100 * motiontarget.x;
				}
				if (moveRight == true)
				{
					camera.position.z -= FrameTime * 100 * horizontalmotiontarget.z;
					camera.position.x -= FrameTime * 100 * horizontalmotiontarget.x;
				}
				if (moveLeft == true)
				{
					camera.position.z += FrameTime * 100 * horizontalmotiontarget.z;
					camera.position.x += FrameTime * 100 * horizontalmotiontarget.x;
				}

				for (ix = 0; ix < ground.geometry.vertices.length / AMOUNTY; ix++)
				{
					for (iy = 0; iy < ground.geometry.vertices.length / AMOUNTX; iy++)
					{
						//set the wave 
						ground.geometry.vertices[ix * AMOUNTX + iy].y += 1 * Math.sin((clock.elapsedTime * Math.PI + 7 * Math.PI * (ix / AMOUNTX)))
						ground.geometry.vertices[ix * AMOUNTX + iy].y += 1 * Math.sin((clock.elapsedTime * Math.PI * 1.3 + 13 * Math.PI * (iy / AMOUNTY)))

						ground.geometry.dynamic = true;
						ground.geometry.verticesNeedUpdate = true;
						// particles[ix][iy].position.y += .1 * Math.sin(clock.elapsedTime + (2 * Math.PI * particles[0].length / iy))

					}
				}

				// // change camera height
				// TargetY = particles[Math.floor(camera.position.x / SEPARATION)][Math.floor(camera.position.z / SEPARATION)].position.y + 50;

				// camera.position.y += (TargetY - camera.position.y) * .1;


				renderer.render( scene, camera );
			}

			animate();

		</script>
	</body>
</html>
